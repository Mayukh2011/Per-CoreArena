Design overview:
Linkedlist was created which contains information about the block of memory that was received by the Kernel.
The information includes all the nodes that are free as well as nodes that are occupied. A flag was set to implement
this information.At first the program asks for a chunk of memory from the kernel which would be a multiple of the page
size. The amount of memory the program asks for depends on  the malloc calls.
Buddy memory allocation is used to allocate the memory for each calls. The returned address is maintained at an 8 byte
boundary.

Arena Implementation:
To implement the arena, number of cores were determined and accordingly the a structure was created which contains a separate head for each arena generated.
basically, now each arena is a separate linked list with its own head. To allocate each thread to a particular arena, a global array of mutexes was created.
the array was traversed checking status of each arena i.e whether the particular arena was locked or unlocked. Based on the status of the arena, each thread
was allocated. Now, if the number of threads exceeded the number of arena available then a simple spin lock was created to make sure that the thread gets looped
around until one of the arena is available.
On the first iteration, each of the Arena structure, Array of arena, array of locks were initiated.This was achieved by using a global counter and a global mutex.

Malloc stat and Malloc info implementation:
Malloc stats:
malloc stats is implemented to give the status of each arena. global counters arrays were created to keep track of the number of allocation requests and free requests.
stats of each arena was saved in the corresponding indexes in the array.These global arrays were then iterated over and then printed to get the malloc stats for each arena.
Malloc info:
Malloc info contains the information regarding the total allocation request and free requests, total number of blocks etc. generated by the users irrespective of individual arenas.
A structure was created to persist all the information collected from the free list created above and is populated in the new structure for the Malloc info. This structure is then
returned.

Design Decisions:
A  List was created that contains the information about the memory blocks because it would make it easier to keep track
of free memory blocks and allocated blocks even after dividing the blocks using buddy allocation.The list also contains an
extra bit of information which points to the starting memory address of each memory block including whether it is free or not.
if a certain size of memory is asked, the list is traversed to find the a memory unit that can fit the requested size. if the
size is too big then the block is divided again and again by half unless and until it can accommodate the requested size which leads
to less memory fragmentation.
sbrk is used to get a large memory chunk from the kernel. if the memory asked for is bigger than the page size, the smallest possible
amount of memory which must be a multiple of page size is calculated and is requested by the kernel.The program does not consider two separate
memory calls to the kernel as buddies and thus refuse to merge them even they are adjacent and are of same size. Hence, it might lead to
higher number of memory fragmentation than usual.Since the list also keeps track of all the allocated addresses it might lead to slower
performance.
To iterate over the global arena locks, trylock was used. By using trylock, the area which is unlocked is found out and the thread is then allocated
for that arena.
